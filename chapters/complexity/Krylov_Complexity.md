# Chapter: Krylov Complexity in Cellular Automata

Krylov complexity is a concept originating from quantum dynamics, which quantifies how the complexity of a quantum system evolves over time. Recently, it has found applications in broader contexts, including the study of classical systems like cellular automata. Krylov complexity measures how a system's state spreads over a basis of dynamically accessible states. This chapter introduces Krylov complexity, discusses its relevance to cellular automata, and demonstrates how to compute it using Python.

---

## Introduction to Krylov Complexity

Krylov complexity (KC) tracks the time-evolution of a system's state in a particular basis. The Krylov basis is constructed iteratively, representing the dynamically accessible space generated by the action of an evolution operator (e.g., a Hamiltonian in quantum systems or a rule in cellular automata).

Key characteristics of Krylov complexity:
- **Low Krylov Complexity:** Indicates that a system remains confined to a small number of accessible states.
- **High Krylov Complexity:** Suggests that the system explores a wide range of states, indicating chaos or high complexity.

### Why Use Krylov Complexity in Cellular Automata?

1. **State Evolution Analysis:** Tracks how an initial configuration evolves over time.
2. **Characterizing Behavior:** Distinguishes between periodic, chaotic, and complex dynamics.
3. **Basis Construction:** Provides a framework for understanding how states are dynamically connected.

---

## Theoretical Framework

In cellular automata, the state of the system evolves according to a deterministic rule. The Krylov basis can be constructed by:
1. Defining an initial state as a vector.
2. Applying the evolution operator (cellular automaton rule) iteratively.
3. Tracking the states generated by the iterations.

The Krylov complexity at time \(t\) is proportional to the number of unique states visited up to that point.

For cellular automata:
- The initial configuration serves as the starting vector.
- The evolution rule acts as the generator.
- The number of unique states encountered during evolution measures the complexity.

---

## Implementation in Python

### Generating Cellular Automaton States
We begin by generating the states of a cellular automaton using a given rule. For demonstration, we use Rule 30.

```python
import numpy as np

def generate_rule30(initial_state, steps):
    """
    Generate the states of a Rule 30 cellular automaton.

    Parameters:
        initial_state (list): Initial binary state.
        steps (int): Number of time steps.

    Returns:
        np.ndarray: 2D array of automaton states.
    """
    n = len(initial_state)
    grid = np.zeros((steps, n), dtype=int)
    grid[0] = initial_state

    for t in range(1, steps):
        for i in range(1, n - 1):
            left, center, right = grid[t - 1, i - 1], grid[t - 1, i], grid[t - 1, i + 1]
            grid[t, i] = left ^ (center | right)  # Rule 30 logic

    return grid

# Example usage:
initial_state = [0] * 20 + [1] + [0] * 20  # Single '1' in the center
steps = 20
grid = generate_rule30(initial_state, steps)
```

### Constructing the Krylov Basis
Construct the Krylov basis by tracking unique states over time:

```python
def krylov_basis(grid):
    """
    Construct the Krylov basis for a cellular automaton.

    Parameters:
        grid (np.ndarray): 2D array of automaton states.

    Returns:
        list: List of unique states encountered during evolution.
    """
    unique_states = set()

    for row in grid:
        unique_states.add(tuple(row))

    return list(unique_states)

# Example usage:
unique_states = krylov_basis(grid)
print(f"Number of unique states: {len(unique_states)}")
```

### Measuring Krylov Complexity
The Krylov complexity is simply the number of unique states in the basis at each time step:

```python
def krylov_complexity(grid):
    """
    Compute the Krylov complexity over time.

    Parameters:
        grid (np.ndarray): 2D array of automaton states.

    Returns:
        list: Krylov complexity values over time.
    """
    seen_states = set()
    complexity = []

    for row in grid:
        seen_states.add(tuple(row))
        complexity.append(len(seen_states))

    return complexity

# Example usage:
complexity = krylov_complexity(grid)
print(f"Krylov Complexity over time: {complexity}")
```

---

## Visualizing Krylov Complexity

To gain insights into how complexity evolves, visualize the Krylov complexity over time:

```python
import matplotlib.pyplot as plt

plt.plot(range(steps), complexity, marker='o')
plt.xlabel("Time Steps")
plt.ylabel("Krylov Complexity")
plt.title("Krylov Complexity of Rule 30")
plt.show()
```

---

## Applications and Extensions

1. **Behavior Classification:** Use Krylov complexity to differentiate between periodic, chaotic, and complex rules.
2. **State Space Exploration:** Analyze how different initial configurations affect the exploration of state space.
3. **Higher Dimensions:** Extend the methodology to 2D or 3D cellular automata.

---

## Conclusion

Krylov complexity provides a valuable framework for analyzing the dynamical behavior of cellular automata. By tracking the growth of the Krylov basis over time, it offers insights into the accessibility and exploration of states under specific rules. With Python, the computation and visualization of Krylov complexity become straightforward, enabling deeper investigations into the intricate behaviors of cellular automata.

